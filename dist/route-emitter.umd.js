(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.routeEmitter = factory());
})(this, (function () { 'use strict';

	function e$1(){return new function(){let e={"*":[]},t={},n=[],o=!1,c="";return {on:function(t,n){e[t]||(e[t]=[]),e[t].push(n);},once:function(e,n){"*"!==e&&(t[e]||(t[e]=[]),t[e].push(n));},off:function(n,o){if(o)return e[n]&&(e[n]=e[n].filter((e=>e!==o))),t[n]&&(t[n]=t[n].filter((e=>e!==o))),e[n]&&0===e[n].length&&delete e[n],void(t[n]&&0===t[n].length&&delete e[n]);t[n]&&delete t[n],e[n]&&delete e[n];},reset:function(){e={"*":[]},t={},n=[];},emit:function(){const[f,...i]=arguments;function l(t){let o=!1;"*"!==t&&(n.includes(t)||(e[t].every((e=>{const t=e(...i);return "string"!=typeof t||("STOP"!==t.toUpperCase()||(o=!0,!1))})),o||e["*"].forEach((e=>e(f,...i)))));}if(o&&(console.log(`${c} Event "${f}" was triggered.`),i.length>0&&(console.log("Arguments:"),console.log(...i),console.log("^----"))),"*"!==f){if(t[f]){if(n.includes(f))return;t[f].forEach((e=>e(...i))),delete t[f];}e[f]&&l(f);}else {Object.keys(e).forEach((e=>l(e)));}},stop:function(o){if("*"!==o)n.push(o);else {const o=Object.keys(e),c=Object.keys(t);n=[...c,...o];}},start:function(e){n="*"!==e?n.filter((t=>e!=t)):[];},debug:function(e,t){o=!!e,t&&"string"==typeof t&&(c=t);}}}}

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var urlPattern$1 = {exports: {}};

	var urlPattern = urlPattern$1.exports;

	var hasRequiredUrlPattern;

	function requireUrlPattern () {
		if (hasRequiredUrlPattern) return urlPattern$1.exports;
		hasRequiredUrlPattern = 1;
		(function (module, exports) {
			// Generated by CoffeeScript 1.10.0
			var slice = [].slice;

			(function(root, factory) {
			  if (exports !== null) {
			    return module.exports = factory();
			  } else {
			    return root.UrlPattern = factory();
			  }
			})(urlPattern, function() {
			  var P, UrlPattern, astNodeContainsSegmentsForProvidedParams, astNodeToNames, astNodeToRegexString, baseAstNodeToRegexString, concatMap, defaultOptions, escapeForRegex, getParam, keysAndValuesToObject, newParser, regexGroupCount, stringConcatMap, stringify;
			  escapeForRegex = function(string) {
			    return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
			  };
			  concatMap = function(array, f) {
			    var i, length, results;
			    results = [];
			    i = -1;
			    length = array.length;
			    while (++i < length) {
			      results = results.concat(f(array[i]));
			    }
			    return results;
			  };
			  stringConcatMap = function(array, f) {
			    var i, length, result;
			    result = '';
			    i = -1;
			    length = array.length;
			    while (++i < length) {
			      result += f(array[i]);
			    }
			    return result;
			  };
			  regexGroupCount = function(regex) {
			    return (new RegExp(regex.toString() + '|')).exec('').length - 1;
			  };
			  keysAndValuesToObject = function(keys, values) {
			    var i, key, length, object, value;
			    object = {};
			    i = -1;
			    length = keys.length;
			    while (++i < length) {
			      key = keys[i];
			      value = values[i];
			      if (value == null) {
			        continue;
			      }
			      if (object[key] != null) {
			        if (!Array.isArray(object[key])) {
			          object[key] = [object[key]];
			        }
			        object[key].push(value);
			      } else {
			        object[key] = value;
			      }
			    }
			    return object;
			  };
			  P = {};
			  P.Result = function(value, rest) {
			    this.value = value;
			    this.rest = rest;
			  };
			  P.Tagged = function(tag, value) {
			    this.tag = tag;
			    this.value = value;
			  };
			  P.tag = function(tag, parser) {
			    return function(input) {
			      var result, tagged;
			      result = parser(input);
			      if (result == null) {
			        return;
			      }
			      tagged = new P.Tagged(tag, result.value);
			      return new P.Result(tagged, result.rest);
			    };
			  };
			  P.regex = function(regex) {
			    return function(input) {
			      var matches, result;
			      matches = regex.exec(input);
			      if (matches == null) {
			        return;
			      }
			      result = matches[0];
			      return new P.Result(result, input.slice(result.length));
			    };
			  };
			  P.sequence = function() {
			    var parsers;
			    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
			    return function(input) {
			      var i, length, parser, rest, result, values;
			      i = -1;
			      length = parsers.length;
			      values = [];
			      rest = input;
			      while (++i < length) {
			        parser = parsers[i];
			        result = parser(rest);
			        if (result == null) {
			          return;
			        }
			        values.push(result.value);
			        rest = result.rest;
			      }
			      return new P.Result(values, rest);
			    };
			  };
			  P.pick = function() {
			    var indexes, parsers;
			    indexes = arguments[0], parsers = 2 <= arguments.length ? slice.call(arguments, 1) : [];
			    return function(input) {
			      var array, result;
			      result = P.sequence.apply(P, parsers)(input);
			      if (result == null) {
			        return;
			      }
			      array = result.value;
			      result.value = array[indexes];
			      return result;
			    };
			  };
			  P.string = function(string) {
			    var length;
			    length = string.length;
			    return function(input) {
			      if (input.slice(0, length) === string) {
			        return new P.Result(string, input.slice(length));
			      }
			    };
			  };
			  P.lazy = function(fn) {
			    var cached;
			    cached = null;
			    return function(input) {
			      if (cached == null) {
			        cached = fn();
			      }
			      return cached(input);
			    };
			  };
			  P.baseMany = function(parser, end, stringResult, atLeastOneResultRequired, input) {
			    var endResult, parserResult, rest, results;
			    rest = input;
			    results = stringResult ? '' : [];
			    while (true) {
			      if (end != null) {
			        endResult = end(rest);
			        if (endResult != null) {
			          break;
			        }
			      }
			      parserResult = parser(rest);
			      if (parserResult == null) {
			        break;
			      }
			      if (stringResult) {
			        results += parserResult.value;
			      } else {
			        results.push(parserResult.value);
			      }
			      rest = parserResult.rest;
			    }
			    if (atLeastOneResultRequired && results.length === 0) {
			      return;
			    }
			    return new P.Result(results, rest);
			  };
			  P.many1 = function(parser) {
			    return function(input) {
			      return P.baseMany(parser, null, false, true, input);
			    };
			  };
			  P.concatMany1Till = function(parser, end) {
			    return function(input) {
			      return P.baseMany(parser, end, true, true, input);
			    };
			  };
			  P.firstChoice = function() {
			    var parsers;
			    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
			    return function(input) {
			      var i, length, parser, result;
			      i = -1;
			      length = parsers.length;
			      while (++i < length) {
			        parser = parsers[i];
			        result = parser(input);
			        if (result != null) {
			          return result;
			        }
			      }
			    };
			  };
			  newParser = function(options) {
			    var U;
			    U = {};
			    U.wildcard = P.tag('wildcard', P.string(options.wildcardChar));
			    U.optional = P.tag('optional', P.pick(1, P.string(options.optionalSegmentStartChar), P.lazy(function() {
			      return U.pattern;
			    }), P.string(options.optionalSegmentEndChar)));
			    U.name = P.regex(new RegExp("^[" + options.segmentNameCharset + "]+"));
			    U.named = P.tag('named', P.pick(1, P.string(options.segmentNameStartChar), P.lazy(function() {
			      return U.name;
			    })));
			    U.escapedChar = P.pick(1, P.string(options.escapeChar), P.regex(/^./));
			    U["static"] = P.tag('static', P.concatMany1Till(P.firstChoice(P.lazy(function() {
			      return U.escapedChar;
			    }), P.regex(/^./)), P.firstChoice(P.string(options.segmentNameStartChar), P.string(options.optionalSegmentStartChar), P.string(options.optionalSegmentEndChar), U.wildcard)));
			    U.token = P.lazy(function() {
			      return P.firstChoice(U.wildcard, U.optional, U.named, U["static"]);
			    });
			    U.pattern = P.many1(P.lazy(function() {
			      return U.token;
			    }));
			    return U;
			  };
			  defaultOptions = {
			    escapeChar: '\\',
			    segmentNameStartChar: ':',
			    segmentValueCharset: 'a-zA-Z0-9-_~ %',
			    segmentNameCharset: 'a-zA-Z0-9',
			    optionalSegmentStartChar: '(',
			    optionalSegmentEndChar: ')',
			    wildcardChar: '*'
			  };
			  baseAstNodeToRegexString = function(astNode, segmentValueCharset) {
			    if (Array.isArray(astNode)) {
			      return stringConcatMap(astNode, function(node) {
			        return baseAstNodeToRegexString(node, segmentValueCharset);
			      });
			    }
			    switch (astNode.tag) {
			      case 'wildcard':
			        return '(.*?)';
			      case 'named':
			        return "([" + segmentValueCharset + "]+)";
			      case 'static':
			        return escapeForRegex(astNode.value);
			      case 'optional':
			        return '(?:' + baseAstNodeToRegexString(astNode.value, segmentValueCharset) + ')?';
			    }
			  };
			  astNodeToRegexString = function(astNode, segmentValueCharset) {
			    if (segmentValueCharset == null) {
			      segmentValueCharset = defaultOptions.segmentValueCharset;
			    }
			    return '^' + baseAstNodeToRegexString(astNode, segmentValueCharset) + '$';
			  };
			  astNodeToNames = function(astNode) {
			    if (Array.isArray(astNode)) {
			      return concatMap(astNode, astNodeToNames);
			    }
			    switch (astNode.tag) {
			      case 'wildcard':
			        return ['_'];
			      case 'named':
			        return [astNode.value];
			      case 'static':
			        return [];
			      case 'optional':
			        return astNodeToNames(astNode.value);
			    }
			  };
			  getParam = function(params, key, nextIndexes, sideEffects) {
			    var index, maxIndex, result, value;
			    if (sideEffects == null) {
			      sideEffects = false;
			    }
			    value = params[key];
			    if (value == null) {
			      if (sideEffects) {
			        throw new Error("no values provided for key `" + key + "`");
			      } else {
			        return;
			      }
			    }
			    index = nextIndexes[key] || 0;
			    maxIndex = Array.isArray(value) ? value.length - 1 : 0;
			    if (index > maxIndex) {
			      if (sideEffects) {
			        throw new Error("too few values provided for key `" + key + "`");
			      } else {
			        return;
			      }
			    }
			    result = Array.isArray(value) ? value[index] : value;
			    if (sideEffects) {
			      nextIndexes[key] = index + 1;
			    }
			    return result;
			  };
			  astNodeContainsSegmentsForProvidedParams = function(astNode, params, nextIndexes) {
			    var i, length;
			    if (Array.isArray(astNode)) {
			      i = -1;
			      length = astNode.length;
			      while (++i < length) {
			        if (astNodeContainsSegmentsForProvidedParams(astNode[i], params, nextIndexes)) {
			          return true;
			        }
			      }
			      return false;
			    }
			    switch (astNode.tag) {
			      case 'wildcard':
			        return getParam(params, '_', nextIndexes, false) != null;
			      case 'named':
			        return getParam(params, astNode.value, nextIndexes, false) != null;
			      case 'static':
			        return false;
			      case 'optional':
			        return astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes);
			    }
			  };
			  stringify = function(astNode, params, nextIndexes) {
			    if (Array.isArray(astNode)) {
			      return stringConcatMap(astNode, function(node) {
			        return stringify(node, params, nextIndexes);
			      });
			    }
			    switch (astNode.tag) {
			      case 'wildcard':
			        return getParam(params, '_', nextIndexes, true);
			      case 'named':
			        return getParam(params, astNode.value, nextIndexes, true);
			      case 'static':
			        return astNode.value;
			      case 'optional':
			        if (astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes)) {
			          return stringify(astNode.value, params, nextIndexes);
			        } else {
			          return '';
			        }
			    }
			  };
			  UrlPattern = function(arg1, arg2) {
			    var groupCount, options, parsed, parser, withoutWhitespace;
			    if (arg1 instanceof UrlPattern) {
			      this.isRegex = arg1.isRegex;
			      this.regex = arg1.regex;
			      this.ast = arg1.ast;
			      this.names = arg1.names;
			      return;
			    }
			    this.isRegex = arg1 instanceof RegExp;
			    if (!(('string' === typeof arg1) || this.isRegex)) {
			      throw new TypeError('argument must be a regex or a string');
			    }
			    if (this.isRegex) {
			      this.regex = arg1;
			      if (arg2 != null) {
			        if (!Array.isArray(arg2)) {
			          throw new Error('if first argument is a regex the second argument may be an array of group names but you provided something else');
			        }
			        groupCount = regexGroupCount(this.regex);
			        if (arg2.length !== groupCount) {
			          throw new Error("regex contains " + groupCount + " groups but array of group names contains " + arg2.length);
			        }
			        this.names = arg2;
			      }
			      return;
			    }
			    if (arg1 === '') {
			      throw new Error('argument must not be the empty string');
			    }
			    withoutWhitespace = arg1.replace(/\s+/g, '');
			    if (withoutWhitespace !== arg1) {
			      throw new Error('argument must not contain whitespace');
			    }
			    options = {
			      escapeChar: (arg2 != null ? arg2.escapeChar : void 0) || defaultOptions.escapeChar,
			      segmentNameStartChar: (arg2 != null ? arg2.segmentNameStartChar : void 0) || defaultOptions.segmentNameStartChar,
			      segmentNameCharset: (arg2 != null ? arg2.segmentNameCharset : void 0) || defaultOptions.segmentNameCharset,
			      segmentValueCharset: (arg2 != null ? arg2.segmentValueCharset : void 0) || defaultOptions.segmentValueCharset,
			      optionalSegmentStartChar: (arg2 != null ? arg2.optionalSegmentStartChar : void 0) || defaultOptions.optionalSegmentStartChar,
			      optionalSegmentEndChar: (arg2 != null ? arg2.optionalSegmentEndChar : void 0) || defaultOptions.optionalSegmentEndChar,
			      wildcardChar: (arg2 != null ? arg2.wildcardChar : void 0) || defaultOptions.wildcardChar
			    };
			    parser = newParser(options);
			    parsed = parser.pattern(arg1);
			    if (parsed == null) {
			      throw new Error("couldn't parse pattern");
			    }
			    if (parsed.rest !== '') {
			      throw new Error("could only partially parse pattern");
			    }
			    this.ast = parsed.value;
			    this.regex = new RegExp(astNodeToRegexString(this.ast, options.segmentValueCharset));
			    this.names = astNodeToNames(this.ast);
			  };
			  UrlPattern.prototype.match = function(url) {
			    var groups, match;
			    match = this.regex.exec(url);
			    if (match == null) {
			      return null;
			    }
			    groups = match.slice(1);
			    if (this.names) {
			      return keysAndValuesToObject(this.names, groups);
			    } else {
			      return groups;
			    }
			  };
			  UrlPattern.prototype.stringify = function(params) {
			    if (params == null) {
			      params = {};
			    }
			    if (this.isRegex) {
			      throw new Error("can't stringify patterns generated from a regex");
			    }
			    if (params !== Object(params)) {
			      throw new Error("argument must be an object or undefined");
			    }
			    return stringify(this.ast, params, {});
			  };
			  UrlPattern.escapeForRegex = escapeForRegex;
			  UrlPattern.concatMap = concatMap;
			  UrlPattern.stringConcatMap = stringConcatMap;
			  UrlPattern.regexGroupCount = regexGroupCount;
			  UrlPattern.keysAndValuesToObject = keysAndValuesToObject;
			  UrlPattern.P = P;
			  UrlPattern.newParser = newParser;
			  UrlPattern.defaultOptions = defaultOptions;
			  UrlPattern.astNodeToRegexString = astNodeToRegexString;
			  UrlPattern.astNodeToNames = astNodeToNames;
			  UrlPattern.getParam = getParam;
			  UrlPattern.astNodeContainsSegmentsForProvidedParams = astNodeContainsSegmentsForProvidedParams;
			  UrlPattern.stringify = stringify;
			  return UrlPattern;
			}); 
		} (urlPattern$1, urlPattern$1.exports));
		return urlPattern$1.exports;
	}

	var urlPatternExports = requireUrlPattern();
	var UrlPattern = /*@__PURE__*/getDefaultExportFromCjs(urlPatternExports);

	function e(e){let o,r=!1;return e?(o=function(e){let o=e.map((e=>n())),r=o.map((e=>e.promise));return o.promises=r,o.onComplete=t(Promise.all(r)),o}(e),r=!0):o=n(),o.timeout=function(e,n){let o;o=e?Promise.all(n.promises):n.promise;return function(e,r){let i,u=new Promise(((n,t)=>{i=setTimeout((()=>{n(r),Promise.resolve(o);}),e);}));return o.then((()=>clearTimeout(i))),n.onComplete=t(Promise.race([o,u])),n}}(r,o),o}function n(){let e,n;const o=new Promise(((t,o)=>{e=t,n=o;}));return {promise:o,done:e,cancel:n,onComplete:t(o)}}function t(e){return function(n){e.then((e=>n(e)));}}e.sequence=function(n,...t){const o=e(),r=[];const i=function*(e){for(const n of e)yield n;}(n);return function e(n,...t){n.done?o.done(r):n.value(...t).then((n=>{r.push(n),e(i.next(),...t,n);}));}(i.next(),...t),o},e.all=function(n,...t){const o=e(),r=[],i=n.map(((e,n)=>"function"==typeof e?e(...t).then((e=>r[n]=e)):e.then((e=>r[n]=e))));return Promise.all(i).then((()=>o.done(r))),o};

	function historyController ( ) {
	    
	    let wait = null;

	    function write ({state, title, url},  keepHistoryFlag ) {
	            if ( keepHistoryFlag )   window.history.pushState    ( state, '', url );
	            else                     window.history.replaceState ( state, '', url );
	            const isFn = (typeof title === 'function');
	            document.title = isFn ? title ( state.data ) : title;
	        } // setState func.

	        

	    function read () {
	                return window.location.pathname;
	        } // readLocation func.
	    


	    function listen ( fn ) {
	            onpopstate = function onPopState ( event ) {
	                                let { PGID, url, data } = event.state;
	                                if ( !wait )   wait = e ();
	                                fn ( wait, {addressName:PGID, data, url} );
	                                wait = null;
	                            };
	        } // listen func.



	    function back ( steps=1 ) {
	                    wait = e ().timeout ( 1500, 'expire' );   // history.back is asynch operation. It's applied when event 'popstate' is fired
	                    window.history.back ( steps );
	                    wait.onComplete ( d => { if ( d === 'expire')   wait = null; }); // prevent unclosed promises
	                    return wait.promise            
	        } // back func.



	    function go ( steps=1 ) {
	                    wait = e ().timeout ( 1500, 'expire' );   // history.go is asynch operation. It's applied when event 'popstate' is fired
	                    window.history.go ( steps );
	                    wait.onComplete ( d => { if ( d === 'expire')   wait = null; }); // prevent unclosed promises
	                    return wait.promise
	        } // go func.
	    


	    function destroy () {
	            window.onpopstate = null;            
	        } // destroy func.



	    return {
	              write
	            , read
	            , back
	            , go

	            , listen
	            , destroy
	        }
	} // historyController func.

	function _historyActions ( dependencies, state ) {

	return function _historyActions ( task, {addressName, data, url}) {
	            const 
	                  { eBus, API } = dependencies
	                , lastLocation  = state.lastLocation
	                ;
	            API.navigate ( addressName, data, true );  // last argument is 'historyEvent' flag.
	            if ( lastLocation === url )   eBus.emit ( '_RELOAD', addressName, data, url );
	            else                          eBus.emit ( '_CHANGE' , addressName, data, url );
	            task.done ( addressName, data );
	}} // _historyActions func.

	function _locationChange ( dependencies, state ) {
	return function _locationChange () {
	            const { eBus, history, API } = dependencies;
	            let 
	                  reload = false
	                , missingURL = true
	                , usingRedirect = false
	                ;
	            const 
	                  lastLocation = sessionStorage.getItem ( state.SSName )
	                , url = history.read ()
	                ;
	            if ( lastLocation && lastLocation === url )   reload = true;
	            missingURL = state.rt.every ( ({ name, pattern, title, redirect, data={} }) => {   // Search for address name
	                                let res = pattern.match ( url );
	                                if ( res ) {
	                                            if ( redirect ) {
	                                                    API.navigate ( redirect, data, true );
	                                                    usingRedirect = true;
	                                                    return false
	                                                }
	                                            sessionStorage.setItem ( state.SSName, url );
	                                            state.lastLocation = url;
	                                            state.lastAddress  = name;
	                                            history.write ({ 
	                                                              state : { PGID: name, url, data:res }
	                                                            , url
	                                                            , title
	                                                        }, true );
	                                                        
	                                            if ( reload )    eBus.emit ( '_RELOAD', name, res, url );
	                                            else             eBus.emit ( '_CHANGE',  name, res, url );
	                                            return false   // Prevents duplicated data in the browser.history
	                                    }
	                                return true
	                        });
	            if ( missingURL ) {   // URL is not defined in the address list
	                        if ( usingRedirect )   return
	                        eBus.emit ( '_ERROR', { code: 404, message: `There is no defined address for path "${url}".` });
	                        return 
	                }
	            state.lastRoute = url;
	}} // _locationChange func.

	function _setAddressRecord ( dependencies, state ) {
	return function _setAddressRecord ({name, path, title, inHistory, redirect, data }) {
	    
	    if ( name == null      )   return null
	    if ( path == null      )   return null
	    if ( title == null     )   title = state.appName;
	    if ( inHistory == null )   inHistory = false;

	    const
	          { UrlPattern } = dependencies 
	        , pattern = new UrlPattern ( path )
	        ;
	    return { name, path, title, inHistory, pattern, redirect, data }
	}} // _setAddressRecord func.

	function createURL ( dependencies, state ) {
	/**
	 * @function createURL
	 * @description Creates URL from address name and data
	 * @param {string} addressName - Name of the address
	 * @param {object|string} data - Data to be used for creating URL(optional)
	 */
	return function createURL ( addressName, data={} ) {
	        const { routes } = state;
	        if ( !routes[addressName] ) {  // If address is not registered
	                    console.error ( `Address "${addressName}" is not registered` );
	                    return null
	            }
	    
	        const { pattern } = routes [ addressName ];

	        try {
	                const url = pattern.stringify ( data );
	                return url
	            }
	        catch ( err ) {
	                console.error ( `Data provided for address "${addressName}" is not correct.`);
	                return null
	            }
	}} // createURL func.

	function getCurrentAddress ( dependencies, state ) {
	return function getCurrentAddress () {
	        const 
	                { lastAddress, lastLocation, routes } = state
	                , { pattern } = routes[lastAddress]
	                ;
	        let data = pattern.match ( lastLocation );
	        return [ state.lastAddress, data ]
	}} // getCurrentAddress func.

	function destroy ( dependencies, state ) {
	return function destroy () {
	        const { eBus, history, dead } = dependencies;
	        state.isActive = false;
	        eBus.off ();
	        history.destroy ();
	        sessionStorage.removeItem ( state.SSName );
	        dependencies.API = {
	                              on : dead
	                            , navigate : dead
	                            , destroy : dead
	                        };
	}} // destroy func.

	function listActiveAddresses ( dependencies, state ) {
	return function listActiveAddresses () {
	    return state.rt.map ( r => r.name )
	}} // listActiveAddresses func.

	function listActiveRoutes ( dependencies, state ) {
	return function listActiveRoutes () {
	    const { rt } = state;
	    return rt.map ( r => `${r.name} ---> ${r.path}`)
	}} // listActiveRoutes func.

	function navigate ( dependencies, state ) {
	const { history, eBus } = dependencies;
	return function navigate ( addressName, data={}, historyEvent=false ) {
	    // historyEvent flag should be 'true' if 'navigate' is called from '_historyActions' or in _locationChange is detected 'reload' event.
	    // This historyEvent flag prevents history line - forwards and backwards. 
	    if ( !state.isActive ) {  // Don't use navigate before router.run()
	                console.error ( 'Router is not active. Use router.run() to activate it.' );
	                return
	        }
	    const { lastAddress, lastLocation, routes } = state;
	    if ( !routes[addressName] ) {  // If address is not registered
	                console.error ( `Address "${addressName}" is not registered` );
	                eBus.emit ( '_ERROR', { code: 404, message: `Address "${addressName}" is not registered` });
	                return  
	        }

	    let oldHistoryFlag = false;   // False means replaceState, true means pushState
	    const { pattern, title, redirect, data:redirectData } = routes[addressName];
	    if ( redirect ) {
	                navigate ( redirect, redirectData );
	                return
	        }
	    if ( lastAddress )   oldHistoryFlag = routes[ lastAddress ].inHistory;
	    try {
	                const url = pattern.stringify ( data );
	                if ( url === lastLocation )   return   // If same path, do nothing
	                state.lastLocation = url;
	                sessionStorage.setItem ( state.SSName, url );
	                state.lastAddress  = addressName;
	                if ( historyEvent )   oldHistoryFlag = false;   // Ignore 'inHistory' flag if event is coming from history or refresh event
	                history.write ({ 
	                                  state : { PGID: addressName, url, data }
	                                , url
	                                , title
	                            }, oldHistoryFlag ); 
	        } 
	    catch ( err ) {
	                eBus.emit ( '_ERROR', { code: 400, message: `Data provided for address "${addressName}" is not correct. ${err}` });
	                return
	        }
	}} // navigate func.

	function setAddresses ( dependencies, state ) {
	return function setAddresses ( list, cancelList=[] ) {
	     const { _setAddressRecord } = dependencies.inAPI;
	     list.forEach ( route => {
	                const addressRecord = _setAddressRecord ( route );
	                if ( !addressRecord )   return
	                if ( cancelList.includes ( addressRecord.name ) )   return

	                const name = addressRecord.name;
	                state.rt.push ( addressRecord );
	                state.routes[name] = addressRecord;
	        });
	      return dependencies.API
	}} // setAddresses func.

	function removeAddresses ( dependencies, state ) {
	return function removeAddresses ( removeList ) {
	    const { rt } = state;
	    state.rt = rt.reduce (( res, item ) => {
	                                        let { name } = item;
	                                        if ( removeList.includes ( name )) {
	                                                    delete state.routes [ name ];
	                                                    return res
	                                            }
	                                        res.push ( item );
	                                        return res
	                            }, []);
	    return dependencies.API
	}} // removeAddresses func.

	function run ( dependencies, state ) {
	return function run () {
	    const { inAPI, history } = dependencies;
	    state.isActive = true;
	    history.listen ( inAPI._historyActions );
	    inAPI._locationChange ();
	}} // run func.

	var methods = {
	                // inAPI methods
	                  _historyActions
	                , _locationChange
	                , _setAddressRecord       // Individual address record preparation

	                // API methods
	                , createURL
	                , getCurrentAddress
	                , destroy
	                , listAciveAddresses: listActiveAddresses
	                , listActiveRoutes
	                , navigate
	                , removeAddresses
	                , run
	                , setAddresses
	            };

	function routeEmitter ( config ) {
	  const 
	      eBus  = e$1 ()
	    , history = historyController ()
	    , { appName, sessionStorageKey } = config || {}
	    , state = {
	                  lastLocation : ''   // Last url
	                , lastAddress : null  // Last address name
	                , SSName : '_routeEmmiterLastLocation' // Session Storage(SS) key for last location
	                , appName : 'App Name' // Used as a title for addresses without title property
	                , rt : []      // Addresses as a list
	                , routes : {}  // Addresses definitions
	                , isActive : false  // If router is running - true, else - false
	            }
	    , dead = () => console.error ( 'Router was destroyed' )
	    , dependencies = { UrlPattern, eBus, history, dead }
	    , APImethods = {}
	    , inAPI = {}
	    ;
	    
	  if ( appName           && ( typeof appName === 'string'           ))   state.appName = appName;
	  if ( sessionStorageKey && ( typeof sessionStorageKey === 'string' ))   state.SSName = sessionStorageKey;  

	  Object.entries ( methods ).forEach ( ([name,fn]) => {
	                if ( name.startsWith ( '_' ) )   inAPI[name]      = fn ( dependencies, state );
	                else                             APImethods[name] = fn ( dependencies, state );
	      });
	  dependencies.inAPI = inAPI;
	  dependencies.API = {
	              // Event related methods
	                onChange  : fn => { eBus.on ( '_CHANGE',  fn ); return dependencies.API }
	              , onError   : fn => { eBus.on ( '_ERROR',   fn ); return dependencies.API }
	              , onReload  : fn => { eBus.on ( '_RELOAD', fn ); return dependencies.API }
	              // History related methods
	              , back      : steps => history.back ( steps )
	              , forward   : steps => history.go   ( steps )
	              // Router related methods
	              , ...APImethods
	      };
	  return dependencies.API
	}  // ReactEmmiter func.

	return routeEmitter;

}));
